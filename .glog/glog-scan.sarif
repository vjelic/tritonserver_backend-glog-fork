{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-5e297386-c052-45a5-814c-ec23bfd3a7a0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from a source address to a destination address. This function can lead to various vulnerabilities if not used properly. The most common vulnerability is a buffer overflow, which occurs when the size of the data being copied exceeds the size of the destination buffer. This can lead to overwriting of adjacent memory and can cause unexpected behavior, including program crashes, data corruption, and execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to fix the vulnerability in the `memcpy` function:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void* dst, size_t dst_size, const void* src, size_t byte_size) {\n    if (dst_size >= byte_size) {\n        memcpy(dst, src, byte_size);\n    } else {\n        // Handle error: destination buffer is too small\n    }\n}\n```\n\nIn this example, we first check if the destination buffer is large enough to hold the source data. If it is, we proceed with the copy operation. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7a19fd16-b530-4eab-8519-967379531a90",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from a source address to a destination address. This function can lead to various vulnerabilities if not used properly. The most common vulnerability is a buffer overflow, which occurs when the size of the data being copied exceeds the size of the destination buffer. This can lead to overwriting of adjacent memory and can cause unexpected behavior, including program crashes, data corruption, and execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is an example of how to fix the vulnerability in the `memcpy` function:\n\n```cpp\n#include <cstring>\n\nvoid safe_memcpy(void* dst, size_t dst_size, const void* src, size_t byte_size) {\n    if (dst_size >= byte_size) {\n        memcpy(dst, src, byte_size);\n    } else {\n        // Handle error: destination buffer is too small\n    }\n}\n```\n\nIn this example, we first check if the destination buffer is large enough to hold the source data. If it is, we proceed with the copy operation. If it's not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-70e772e4-30ed-462b-a622-d6d74a191f70",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. This can lead to corruption of data, crash of the application, or even code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(output_buffer, output_base, output_byte_size)\n```\n\nIf `output_byte_size` is larger than the size of `output_buffer`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before the `memcpy` operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (output_byte_size <= sizeof(output_buffer)) {\n    memcpy(output_buffer, output_base, output_byte_size);\n} else {\n    // Handle the error, e.g., by truncating the data or allocating a larger buffer\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP Buffer Overflow Attack](https://owasp.org/www-community/attacks/Buffer_overflow_attack)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-35557c7b-a3bc-4b1e-9128-a2a1692898fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used properly. In the provided code snippet, `malloc(BUF_SIZE + ALIGN_SIZE)`, there is a potential for integer overflow. If `BUF_SIZE` and `ALIGN_SIZE` are user-controlled and large enough, their sum could overflow and result in a smaller buffer being allocated than expected. This could lead to buffer overflow vulnerabilities, where data can be written past the end of the allocated buffer, potentially leading to code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Always check for integer overflows when calculating the size to pass to `malloc`.\n2. Limit the range of acceptable values for `BUF_SIZE` and `ALIGN_SIZE`.\n3. Always check the return value of `malloc` to ensure that the memory allocation was successful.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```c++\n#include <climits>\n#include <cstdlib>\n\n// ...\n\nif (BUF_SIZE > INT_MAX - ALIGN_SIZE) {\n    // Handle error: size calculation would overflow\n} else {\n    void* buffer = malloc(BUF_SIZE + ALIGN_SIZE);\n    if (buffer == NULL) {\n        // Handle error: memory allocation failed\n    } else {\n        // Use buffer...\n        free(buffer);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<climits>`: for `INT_MAX`\n- `<cstdlib>`: for `malloc` and `free`\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-42f54076-7186-450e-9264-a3b9d3476d8c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to but not including the first null character. If the string does not have a null character, `strlen` will continue reading memory until it encounters one, which can lead to buffer overflows, memory corruption, and other security issues.\n\nIn the provided code snippet `strlen(\"TYPE_\")`, there is no direct vulnerability as the string is a constant and well-defined. However, if the string was replaced with a variable that could potentially not be null-terminated, it would pose a risk.\n\n## Mitigation Advice\n\nTo mitigate the risk of vulnerabilities associated with the `strlen` function:\n\n- Always ensure that strings are null-terminated.\n- Use safer alternatives to `strlen` when possible, such as `strnlen`, which takes a maximum length parameter and will not read past it.\n- Be cautious when using `strlen` in loops or with user-supplied input, as this can lead to denial of service attacks if the string is very long or does not contain a null character.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, no fix is needed as the string is a constant. However, if the string was a variable, you could use `strnlen` to ensure that the function does not read past the end of the string:\n\n```cpp\n#include <string.h>\n\nchar str[] = \"TYPE_\";\nsize_t len = strnlen(str, sizeof(str));\n```\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed to use it.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-a34171e6-9fcd-4c31-9c3b-1fb238ad4ae6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc()` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used properly. If the `byte_size` argument passed to `malloc()` is controlled by the user or can be manipulated, it can lead to various security issues such as buffer overflow, memory corruption, or denial of service.\n\n## Mitigation Advice\n\n- Always validate and sanitize user input. Never trust data received from the user.\n- Check the return value of `malloc()`. If it returns `NULL`, it means that the memory allocation failed.\n- Avoid using `malloc()` with user-controlled size. If it's necessary, make sure to implement proper error checking and handling.\n- Use secure functions that limit the size of the data written into the buffer, such as `strncpy()` instead of `strcpy()`.\n- Regularly use static code analysis tools to detect potential vulnerabilities.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <stdlib.h>\n\n// Check if byte_size is a reasonable value\nif (byte_size > 0 && byte_size <= MAX_SAFE_SIZE) {\n    void* ptr = malloc(byte_size);\n    if (ptr == NULL) {\n        // Handle error\n    } else {\n        // Use ptr\n        free(ptr);\n    }\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `malloc()` function is part of the C Standard Library, so no additional libraries are needed.\n\n## References\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-99e1c0cb-da5f-4830-823f-9b65071fcebf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to a vulnerability if the size of the data being copied is greater than the size of the destination buffer. This can lead to overwriting of adjacent memory and can potentially lead to code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the data being copied is greater than the size of the destination buffer, then the program should handle this condition appropriately, such as by truncating the data, allocating a larger buffer, or reporting an error.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```cpp\nif (copy_params->byte_size_ <= sizeof(copy_params->dst_)) {\n    memcpy(copy_params->dst_, copy_params->src_, copy_params->byte_size_);\n} else {\n    // Handle error condition\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f086bba5-3742-4016-aded-74047c10ce94",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code, if `batch_1_size` is larger than the size of `buffer + buffer_offset + idx * batch_1_size`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to serious security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code:\n\n```cpp\nsize_t buffer_size = sizeof(buffer) - buffer_offset - idx * batch_1_size;\nif (batch_1_size <= buffer_size) {\n    memcpy(buffer + buffer_offset + idx * batch_1_size, buffer + buffer_offset, batch_1_size);\n} else {\n    // Handle error\n}\n```\n\nIn this code, we calculate the size of the destination buffer and check if `batch_1_size` is less than or equal to `buffer_size` before calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-5e297386-c052-45a5-814c-ec23bfd3a7a0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend_common.cc"
                },
                "region": {
                  "startLine": 705,
                  "startColumn": 4,
                  "endLine": 705,
                  "endColumn": 31,
                  "charOffset": 24236,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(dst, src, byte_size)",
                    "rendered": {
                      "text": "memcpy(dst, src, byte_size)",
                      "markdown": "`memcpy(dst, src, byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/backend_common.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24236,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7a19fd16-b530-4eab-8519-967379531a90",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend_common.cc"
                },
                "region": {
                  "startLine": 702,
                  "startColumn": 6,
                  "endLine": 702,
                  "endColumn": 33,
                  "charOffset": 24191,
                  "charLength": 27,
                  "snippet": {
                    "text": "memcpy(dst, src, byte_size)",
                    "rendered": {
                      "text": "memcpy(dst, src, byte_size)",
                      "markdown": "`memcpy(dst, src, byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/backend_common.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24191,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst, <size of dst>,  src,  byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-70e772e4-30ed-462b-a622-d6d74a191f70",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/backends/bls/src/bls.cc"
                },
                "region": {
                  "startLine": 283,
                  "startColumn": 4,
                  "endLine": 283,
                  "endColumn": 56,
                  "charOffset": 11921,
                  "charLength": 52,
                  "snippet": {
                    "text": "memcpy(output_buffer, output_base, output_byte_size)",
                    "rendered": {
                      "text": "memcpy(output_buffer, output_base, output_byte_size)",
                      "markdown": "`memcpy(output_buffer, output_base, output_byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "examples/backends/bls/src/bls.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11921,
                        "charLength": 52
                      },
                      "insertedContent": {
                        "text": "memcpy_s(output_buffer, <size of output_buffer>,  output_base,  output_byte_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-35557c7b-a3bc-4b1e-9128-a2a1692898fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/device_memory_tracker.cc"
                },
                "region": {
                  "startLine": 71,
                  "startColumn": 27,
                  "endLine": 71,
                  "endColumn": 56,
                  "charOffset": 3397,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc(BUF_SIZE + ALIGN_SIZE)",
                    "rendered": {
                      "text": "malloc(BUF_SIZE + ALIGN_SIZE)",
                      "markdown": "`malloc(BUF_SIZE + ALIGN_SIZE)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/device_memory_tracker.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3397,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-42f54076-7186-450e-9264-a3b9d3476d8c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend_common.cc"
                },
                "region": {
                  "startLine": 1116,
                  "startColumn": 49,
                  "endLine": 1116,
                  "endColumn": 64,
                  "charOffset": 36235,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(\"TYPE_\")",
                    "rendered": {
                      "text": "strlen(\"TYPE_\")",
                      "markdown": "`strlen(\"TYPE_\")`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/backend_common.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36235,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"TYPE_\", <size of \"TYPE_\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/backend_common.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 36235,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(\"TYPE_\", <size of \"TYPE_\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a34171e6-9fcd-4c31-9c3b-1fb238ad4ae6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "examples/backends/bls/src/bls_utils.cc"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 20,
                  "endLine": 59,
                  "endColumn": 37,
                  "charOffset": 2976,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(byte_size)",
                    "rendered": {
                      "text": "malloc(byte_size)",
                      "markdown": "`malloc(byte_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "examples/backends/bls/src/bls_utils.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2976,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-99e1c0cb-da5f-4830-823f-9b65071fcebf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend_common.cc"
                },
                "region": {
                  "startLine": 66,
                  "startColumn": 2,
                  "endLine": 66,
                  "endColumn": 71,
                  "charOffset": 2498,
                  "charLength": 69,
                  "snippet": {
                    "text": "memcpy(copy_params->dst_, copy_params->src_, copy_params->byte_size_)",
                    "rendered": {
                      "text": "memcpy(copy_params->dst_, copy_params->src_, copy_params->byte_size_)",
                      "markdown": "`memcpy(copy_params->dst_, copy_params->src_, copy_params->byte_size_)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/backend_common.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2498,
                        "charLength": 69
                      },
                      "insertedContent": {
                        "text": "memcpy_s(copy_params->dst_, <size of copy_params->dst_>,  copy_params->src_,  copy_params->byte_size_)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f086bba5-3742-4016-aded-74047c10ce94",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/backend_input_collector.cc"
                },
                "region": {
                  "startLine": 1099,
                  "startColumn": 6,
                  "endLine": 1101,
                  "endColumn": 23,
                  "charOffset": 43665,
                  "charLength": 110,
                  "snippet": {
                    "text": "memcpy(\n          buffer + buffer_offset + idx * batch_1_size, buffer + buffer_offset,\n          batch_1_size)",
                    "rendered": {
                      "text": "memcpy(\n          buffer + buffer_offset + idx * batch_1_size, buffer + buffer_offset,\n          batch_1_size)",
                      "markdown": "`memcpy(\n          buffer + buffer_offset + idx * batch_1_size, buffer + buffer_offset,\n          batch_1_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/backend_input_collector.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 43665,
                        "charLength": 110
                      },
                      "insertedContent": {
                        "text": "memcpy_s(\n          buffer + buffer_offset + idx * batch_1_size, <size of \n          buffer + buffer_offset + idx * batch_1_size>,  buffer + buffer_offset, \n          batch_1_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}